# 引擎工作流程详细设计

本文档基于POC代码的三协程模型，详细描述引擎内部的工作流程，包括启动、任务提交、执行、状态管理、控制信号处理、优雅退出等全生命周期流程。

## 1. Engine启动流程

### 1.1 初始化阶段

1. **加载配置**
   - 读取配置文件（engine.yaml），解析Executor并发池大小、默认超时时间、数据库类型等参数
   - 初始化日志系统

2. **数据库连接**
   - 根据配置的数据库类型（SQLite/PostgreSQL/MySQL），创建数据库连接
   - 初始化Repository实例（WorkflowRepository、WorkflowInstanceRepository、TaskRepository、JobFunctionMetaRepository）
   - 执行数据库迁移（如需要）

3. **Job函数恢复**
   - 从数据库加载所有已注册的Job函数元数据
   - 通过反射机制从二进制程序中匹配函数实例
   - 重建内存函数映射表（函数唯一标识 → 函数实例）
   - 校验函数二进制哈希，不一致则更新元数据

4. **Executor初始化**
   - 创建Executor实例，设置并发池大小
   - 创建任务提交通道（taskChannel），用于接收待执行任务
   - 创建状态通道映射（stateChannelMap），用于监听任务执行状态
   - 启动Executor主协程（见4.1节）

5. **状态管理器初始化**
   - 初始化WorkflowInstance管理器
   - 加载未完成的WorkflowInstance（状态为Running/Paused），准备恢复执行

6. **标记Engine为运行状态**
   - 设置`running = true`
   - 记录启动日志

### 1.2 恢复未完成实例

1. 从数据库查询所有状态为`Running`或`Paused`的WorkflowInstance
2. 对每个实例：
   - 加载断点数据（BreakpointData）
   - 重建DAG拓扑结构
   - 恢复上下文数据（ContextData）
   - 如果状态为`Running`，则触发恢复流程（见6.2节）
   - 如果状态为`Paused`，保持暂停状态，等待用户手动恢复

## 2. Workflow提交与WorkflowInstance创建流程

### 2.1 Workflow模板持久化

1. **接收Workflow提交请求**
   - 用户通过`Engine.SubmitWorkflow(workflow Workflow)`提交Workflow模板

2. **Workflow校验**
   - 校验Workflow ID唯一性
   - 校验Task ID不重复
   - 预校验循环依赖（快速检查）

3. **持久化Workflow模板**
   - 检查数据库中是否存在该Workflow ID
   - 如果不存在，通过`WorkflowRepository.Save(workflow)`插入新记录
   - 如果已存在，更新Workflow定义（版本管理）

### 2.2 WorkflowInstance创建

1. **创建实例**
   - 生成WorkflowInstance ID（UUID）
   - 设置初始状态为`Ready`
   - 记录创建时间、关联的Workflow ID
   - 通过`WorkflowInstanceRepository.Save(instance)`持久化实例记录

2. **初始化运行时DAG**
   - 从Workflow模板加载Task列表和依赖关系
   - 构建DAG拓扑结构（使用go-dag库）
   - 初始化processedNodes（sync.Map）和candidateNodes（sync.Map）
   - 将根节点（入度为0的Task）加入candidateNodes队列

3. **创建WorkflowController**
   - 创建WorkflowController实例，绑定到WorkflowInstance
   - 创建controlSignalChannel（带缓冲，容量建议10）
   - 提供`GetControlSignalChannel()`方法，返回channel的副本供goroutine使用

4. **启动WorkflowInstance管理协程**
   - 启动任务提交协程（见2.3节）
   - 启动控制信号处理协程（见2.4节）

5. **返回WorkflowController**
   - 返回给用户，用于后续控制WorkflowInstance生命周期

### 2.3 任务提交协程（Goroutine 1）

**职责**：从WorkflowInstance中不断取出可执行的任务，提交给Executor执行。

**工作流程**：

1. **循环获取可执行任务**
   ```go
   for {
       // 1. 检查控制信号
       select {
       case signal := <-controlSignalChannel:
           if signal == Pause || signal == Terminate {
               // 退出循环，等待控制信号处理协程处理
               return
           }
       default:
       }
       
       // 2. 从WorkflowInstance获取可执行任务
       availableTasks := workflowInstance.GetAvailableTasks()
       
       if len(availableTasks) == 0 {
           // 检查是否所有任务都已完成
           if workflowInstance.IsAllTasksCompleted() {
               // 更新WorkflowInstance状态为Success
               workflowInstance.UpdateStatus("Success")
               return
           }
           // 短暂休眠，避免CPU占用过高
           time.Sleep(10 * time.Millisecond)
           continue
       }
       
       // 3. 提交任务到Executor
       for _, task := range availableTasks {
           // 更新任务状态为Pending
           task.UpdateStatus("Pending")
           
           // 提交到Executor的taskChannel
           executor.SubmitTask(task)
           
           // 标记任务为已处理（加入processedNodes）
           workflowInstance.MarkTaskProcessed(task.ID)
       }
   }
   ```

2. **获取可执行任务的逻辑**（WorkflowInstance内部方法）
   - 遍历candidateNodes，检查每个候选节点
   - 对于每个候选节点：
     - 检查是否已在processedNodes中，如果是则跳过
     - 获取该节点的所有父节点
     - 检查所有父节点是否都在processedNodes中
     - 如果所有父节点都已处理，则该节点可执行
   - 返回所有可执行的节点列表

3. **退出条件**
   - 接收到`Pause`或`Terminate`控制信号
   - 所有任务都已完成（WorkflowInstance状态变为Success）
   - WorkflowInstance状态变为Failed（某个关键任务失败）

### 2.4 控制信号处理协程（Goroutine 2）

**职责**：监听controlSignalChannel，处理来自用户的控制信号（暂停、恢复、终止）。

**工作流程**：

```go
for {
    select {
    case signal := <-controlSignalChannel:
        switch signal {
        case Pause:
            handlePause()
        case Resume:
            handleResume()
        case Terminate:
            handleTerminate()
        }
    case <-ctx.Done():
        // Engine关闭信号
        return
    }
}
```

**处理逻辑**：

1. **暂停（Pause）**
   - 停止任务提交协程（通过发送Pause信号到controlSignalChannel）
   - 等待正在执行的任务完成（通过Executor查询当前运行任务列表）
   - 记录断点数据：
     - 已完成的Task列表（从processedNodes提取）
     - 当前运行中的Task ID列表（从Executor获取）
     - DAG拓扑快照（序列化当前DAG状态）
     - 上下文数据（ContextData，Task间传递的中间结果）
     - 最后更新时间
   - 更新WorkflowInstance状态为`Paused`
   - 持久化断点数据到数据库（通过WorkflowInstanceRepository.UpdateBreakpoint）
   - 触发Workflow状态变更Handler（如果有配置）

2. **恢复（Resume）**
   - 从数据库加载断点数据
   - 重建DAG拓扑结构
   - 恢复上下文数据
   - 更新各Task的入度（基于已完成的Task列表）
   - 更新WorkflowInstance状态为`Running`
   - 重新启动任务提交协程
   - 触发Workflow状态变更Handler（如果有配置）

3. **终止（Terminate）**
   - 停止任务提交协程
   - 通过Executor中断所有正在执行的任务（发送取消信号到任务的context）
   - 记录终止原因和断点数据
   - 更新WorkflowInstance状态为`Terminated`
   - 持久化到数据库
   - 触发Workflow状态变更Handler（如果有配置）

4. **状态Handler触发**
   - 检查Workflow是否配置了状态变更Handler
   - 如果配置了，根据新状态（Paused/Resumed/Terminated/Success/Failed）调用对应的Handler
   - Handler执行失败不影响主流程，仅记录日志

## 3. Executor内部流程

### 3.1 Executor主协程（任务调度）

**职责**：监听taskChannel，接收待执行任务，分配给Worker协程执行。

**工作流程**：

```go
// Executor启动时创建的主协程
func (e *Executor) run() {
    // 创建Worker协程池
    for i := 0; i < e.poolSize; i++ {
        go e.worker(i)
    }
    
    // 主循环：监听任务提交通道
    for {
        select {
        case task := <-e.taskChannel:
            // 分配到空闲Worker
            e.dispatchTask(task)
        case <-e.shutdownChannel:
            // 优雅关闭
            e.gracefulShutdown()
            return
        }
    }
}
```

### 3.2 Worker协程（任务执行）

**职责**：执行具体的Task，监听任务状态，调用Task Handler。

**工作流程**：

```go
func (e *Executor) worker(id int) {
    for {
        select {
        case task := <-e.taskQueue:
            e.executeTask(task)
        case <-e.shutdownChannel:
            return
        }
    }
}

func (e *Executor) executeTask(task *Task) {
    // 1. 更新任务状态为Running
    task.UpdateStatus("Running")
    taskRepository.UpdateStatus(task.ID, "Running")
    
    // 2. 从内存函数映射表获取Job函数
    jobFunc := jobFunctionRegistry.GetFunction(task.JobFuncName)
    if jobFunc == nil {
        // 函数未找到，标记任务失败
        task.UpdateStatus("Failed")
        taskRepository.UpdateStatus(task.ID, "Failed")
        return
    }
    
    // 3. 创建任务执行上下文（包含WorkflowInstance信息）
    ctx := context.WithValue(context.Background(), "workflowInstance", task.WorkflowInstanceID)
    ctx, cancel := context.WithTimeout(ctx, time.Duration(task.TimeoutSeconds)*time.Second)
    defer cancel()
    
    // 4. 执行Job函数（Job函数返回state channel）
    stateChannel := jobFunc(ctx, task.Params)
    
    // 5. 监听state channel，等待任务完成
    select {
    case state := <-stateChannel:
        handleTaskState(task, state)
    case <-ctx.Done():
        // 超时处理
        handleTaskTimeout(task)
    }
}
```

### 3.3 任务状态处理

**职责**：根据任务执行结果（成功/失败），调用Task对应的Handler，更新WorkflowInstance状态。

**工作流程**：

```go
func handleTaskState(task *Task, state TaskState) {
    // 1. 更新任务状态
    task.UpdateStatus(state.Status)
    taskRepository.UpdateStatus(task.ID, state.Status)
    
    // 2. 保存任务执行结果数据
    if state.Data != nil {
        // 将结果数据保存到WorkflowInstance的上下文数据中
        workflowInstance.AddContextData(task.ID, state.Data)
    }
    
    // 3. 调用Task状态Handler
    if state.Status == "Success" && task.SuccessHandler != nil {
        task.SuccessHandler(task, state.Data)
    } else if state.Status == "Failed" {
        if task.FailureHandler != nil {
            task.FailureHandler(task, state.Error)
        }
        // 检查是否需要重试
        if task.RetryCount > 0 {
            task.RetryCount--
            // 重新加入待执行队列（状态改为Retry）
            workflowInstance.MarkTaskForRetry(task.ID)
        } else {
            // 重试次数用尽，标记WorkflowInstance为Failed
            workflowInstance.UpdateStatus("Failed")
        }
    }
    
    // 4. 通知WorkflowInstance任务完成
    workflowInstance.OnTaskCompleted(task.ID, state.Status)
    
    // 5. 如果任务生成了子任务，处理子任务
    if state.SubTasks != nil {
        for _, subTask := range state.SubTasks {
            workflowInstance.AddSubTask(subTask, task.ID)
        }
    }
}
```

**超时处理**：

```go
func handleTaskTimeout(task *Task) {
    // 1. 更新任务状态为TimeoutFailed
    task.UpdateStatus("TimeoutFailed")
    taskRepository.UpdateStatus(task.ID, "TimeoutFailed")
    
    // 2. 调用超时Handler
    if task.TimeoutHandler != nil {
        task.TimeoutHandler(task)
    }
    
    // 3. 通知WorkflowInstance任务超时
    workflowInstance.OnTaskTimeout(task.ID)
}
```

## 4. WorkflowInstance内部流程

### 4.1 获取可执行任务

**方法**：`GetAvailableTasks() []*Task`

**逻辑**：
1. 遍历candidateNodes（候选节点队列）
2. 对于每个候选节点：
   - 检查是否已在processedNodes中，如果是则跳过
   - 获取该节点的所有父节点（通过DAG.GetParents）
   - 检查所有父节点是否都在processedNodes中
   - 如果所有父节点都已处理，则该节点可执行
3. 同时检查状态为`Retry`的任务（需要重试的任务）
4. 返回所有可执行的任务列表

**优化**：使用candidateNodes队列避免每次遍历整个DAG，提高效率。

### 4.2 添加子任务

**方法**：`AddSubTask(subTask *Task, parentTaskID string) error`

**逻辑**：
1. 校验子任务ID唯一性（不能与已有Task ID重复）
2. 将子任务添加到DAG中（通过DAG.AddVertex）
3. 添加边：parentTaskID -> subTask.ID（通过DAG.AddEdge）
4. 检查子任务是否应该加入候选队列：
   - 如果子任务没有父节点（根节点），或所有父节点都已处理，则加入candidateNodes
5. 持久化子任务到数据库（通过TaskRepository.Save）
6. 触发DAG重新编排（如果需要）

### 4.3 任务完成回调

**方法**：`OnTaskCompleted(taskID string, status string)`

**逻辑**：
1. 将任务ID加入processedNodes
2. 从candidateNodes中移除该任务
3. 获取该任务的所有子节点（通过DAG.GetChildren）
4. 对于每个子节点：
   - 检查是否所有父节点都已处理
   - 如果所有父节点都已处理，将该子节点加入candidateNodes
5. 检查WorkflowInstance是否所有任务都已完成：
   - 如果所有任务都完成且没有失败任务，更新状态为`Success`
   - 如果有失败任务且无法重试，更新状态为`Failed`
6. 触发Workflow状态变更Handler（如果状态改变）

## 5. Engine关闭与优雅退出流程

### 5.1 关闭触发

1. **用户调用Engine.Stop()**
2. **系统信号处理**（SIGTERM/SIGINT）
3. **健康检查失败**（可选，如果配置了健康检查）

### 5.2 优雅退出流程

```go
func (e *Engine) Stop() error {
    // 1. 设置关闭标志
    e.running = false
    e.shutdownChannel <- struct{}{}
    
    // 2. 停止接收新的Workflow提交
    // （通过检查running标志，SubmitWorkflow会返回错误）
    
    // 3. 通知所有WorkflowInstance准备关闭
    for _, instance := range e.workflowInstances {
        // 发送Terminate信号到每个实例的controlSignalChannel
        instance.GetControlSignalChannel() <- Terminate
    }
    
    // 4. 等待所有WorkflowInstance完成终止流程
    // （通过WaitGroup等待所有控制信号处理协程完成）
    e.wg.Wait()
    
    // 5. 关闭Executor
    e.executor.Shutdown()
    // Executor内部流程：
    //   - 停止接收新任务（关闭taskChannel）
    //   - 等待所有正在执行的任务完成（通过context超时控制，最多等待30秒）
    //   - 关闭所有Worker协程
    
    // 6. 保存所有WorkflowInstance的断点数据
    for _, instance := range e.workflowInstances {
        if instance.Status == "Running" {
            // 记录断点数据
            breakpoint := instance.CreateBreakpoint()
            workflowInstanceRepository.UpdateBreakpoint(instance.ID, breakpoint)
            // 更新状态为Paused（而不是Terminated，便于恢复）
            instance.UpdateStatus("Paused")
            workflowInstanceRepository.UpdateStatus(instance.ID, "Paused")
        }
    }
    
    // 7. 关闭数据库连接
    e.workflowRepo.Close()
    e.workflowInstanceRepo.Close()
    e.taskRepo.Close()
    
    // 8. 记录关闭日志
    log.Println("Engine已优雅关闭")
    
    return nil
}
```

### 5.3 Executor关闭流程

```go
func (e *Executor) Shutdown() error {
    // 1. 关闭taskChannel，停止接收新任务
    close(e.taskChannel)
    
    // 2. 等待所有正在执行的任务完成
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    done := make(chan struct{})
    go func() {
        e.wg.Wait() // 等待所有Worker协程完成
        close(done)
    }()
    
    select {
    case <-done:
        // 所有任务完成
        log.Println("Executor: 所有任务已完成")
    case <-ctx.Done():
        // 超时，强制关闭
        log.Println("Executor: 关闭超时，强制终止")
        // 取消所有正在执行的任务的context
        for _, task := range e.runningTasks {
            task.Cancel()
        }
    }
    
    // 3. 关闭所有Worker协程
    close(e.shutdownChannel)
    
    return nil
}
```

## 6. 恢复运行流程

### 6.1 系统重启后的恢复

1. **Engine启动时自动恢复**（见1.2节）
   - 从数据库加载所有状态为`Running`或`Paused`的WorkflowInstance
   - 对每个实例执行恢复流程

### 6.2 WorkflowInstance恢复流程

1. **加载断点数据**
   - 从数据库读取BreakpointData
   - 反序列化DAG拓扑快照
   - 恢复上下文数据（ContextData）

2. **重建运行时状态**
   - 重建DAG拓扑结构（使用go-dag库）
   - 恢复processedNodes（从BreakpointData.CompletedTaskNames）
   - 恢复candidateNodes（基于DAG和processedNodes重新计算）
   - 恢复各Task的执行状态（从数据库查询）

3. **恢复上下文**
   - 将ContextData加载到WorkflowInstance的内存中
   - 供后续任务使用

4. **重新启动执行**
   - 如果原状态为`Running`，更新状态为`Running`
   - 重新启动任务提交协程和控制信号处理协程
   - 从断点位置继续执行

## 7. 关键数据结构

### 7.1 WorkflowInstance运行时结构

```go
type WorkflowInstance struct {
    ID                string
    WorkflowID        string
    Status            string  // Ready/Running/Paused/Terminated/Success/Failed
    DAG               *dag.DAG[*Task]
    ProcessedNodes    *sync.Map  // 已处理的Task ID -> bool
    CandidateNodes    *sync.Map  // 候选Task ID -> *Task
    ContextData       map[string]interface{}  // Task间传递的数据
    ControlSignalChan chan ControlSignal
    Mutex             sync.RWMutex
}
```

### 7.2 控制信号类型

```go
type ControlSignal int

const (
    Pause ControlSignal = iota
    Resume
    Terminate
)
```

### 7.3 任务状态

```go
const (
    TaskStatusPending      = "Pending"
    TaskStatusRunning      = "Running"
    TaskStatusSuccess      = "Success"
    TaskStatusFailed       = "Failed"
    TaskStatusTimeoutFailed = "TimeoutFailed"
    TaskStatusRetry        = "Retry"
)
```

## 8. 并发安全考虑

1. **DAG操作**：go-dag库本身是线程安全的，无需额外加锁
2. **processedNodes和candidateNodes**：使用sync.Map保证并发安全
3. **WorkflowInstance状态更新**：使用Mutex保护状态变更
4. **任务提交**：通过channel进行goroutine间通信，保证线程安全
5. **数据库操作**：Repository层保证事务一致性

## 9. 错误处理与容错

1. **任务执行失败**：
   - 记录错误信息到数据库
   - 根据重试配置决定是否重试
   - 如果重试次数用尽，标记WorkflowInstance为Failed

2. **数据库操作失败**：
   - 重试3次，仍失败则记录告警日志
   - 关键状态变更失败时，回滚到上一个稳定状态

3. **Job函数未找到**：
   - 标记任务为Failed
   - 记录告警日志
   - 不影响其他任务执行

4. **DAG循环依赖**：
   - 在Workflow提交时检测
   - 如果检测到循环依赖，拒绝提交并返回错误

## 10. 性能优化建议

1. **候选节点队列**：使用candidateNodes避免每次遍历整个DAG
2. **批量提交**：任务提交协程可以批量提交多个任务，减少channel通信开销
3. **状态持久化**：采用异步批量持久化，避免频繁数据库操作
4. **上下文数据大小限制**：限制单个WorkflowInstance的ContextData大小（如10MB），防止内存膨胀