# 任务函数保存与加载特性设计文档

## 1. 概述

### 1.1 背景

在任务调度引擎中，用户需要定义各种任务函数来执行具体的业务逻辑。为了支持系统重启后能够自动恢复和执行已定义的任务，需要实现任务函数的持久化和自动加载机制。

### 1.2 设计目标

1. **持久化函数元数据**：将函数的元数据（ID、名称、描述）保存到数据库
2. **自动加载恢复**：系统重启后能够从数据库自动加载函数元数据并恢复函数实例
3. **简化用户使用**：提供友好的API，支持批量注册和自动注册
4. **类型安全**：通过反射机制确保函数签名正确，运行时从函数实例获取类型信息
5. **异步执行**：函数包装为统一签名，支持异步执行和状态通知
6. **简化存储**：不存储参数类型信息，运行时通过反射从函数实例获取，保证数据一致性

### 1.3 核心价值

- **可恢复性**：系统重启后任务函数能够自动恢复，无需重新注册
- **可追溯性**：函数元数据持久化，便于管理和审计
- **易用性**：支持通过函数引用创建任务，自动处理注册流程
- **灵活性**：支持通过函数ID或函数名称查找和执行函数

## 2. 核心概念

### 2.1 函数元数据（FunctionMeta）

函数元数据是函数的描述信息，不包含函数代码本身，包括：

- **ID**：函数的唯一标识（UUID）
- **Name**：函数名称（唯一，用于恢复时的映射）
- **Description**：函数描述
- **CreateTime**：创建时间

**设计说明：**
- **不存储参数类型和返回值类型**：这些信息在运行时通过反射从函数实例获取
- **优势**：
  - 简化存储结构，减少存储空间
  - 保证类型信息始终与函数定义同步
  - 支持自定义类型，无需特殊处理
  - 减少维护成本，函数签名变更时自动反映

### 2.2 函数注册中心（FunctionRegistry）

函数注册中心负责管理函数的注册、查找和恢复：

- **内存映射**：函数ID -> 函数实例的映射
- **元数据管理**：函数ID -> 函数元数据的映射
- **持久化支持**：与存储层交互，保存和加载函数元数据

### 2.3 函数包装（Function Wrapping）

将不同签名的用户函数包装为统一的 `TaskFunction` 类型：

```go
type TaskFunction func(ctx context.Context, params map[string]string) <-chan JobFunctionState
```

包装后的函数：
- 统一签名，便于管理和执行
- 异步执行，通过channel返回结果
- 支持参数类型自动转换

### 2.4 函数映射表（Function Map）

程序重启时，用户需要提供函数名称到函数实例的映射表：

```go
funcMap := map[string]interface{}{
    "FunctionName": FunctionInstance,
    // ...
}
```

系统通过函数名称从数据库恢复函数元数据，然后通过映射表找到对应的函数实例。

## 3. 架构设计

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    用户代码层                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ 定义函数     │  │ 注册函数     │  │ 创建任务     │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────┐
│               FunctionRegistry (注册中心)                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ 函数注册     │  │ 函数包装     │  │ 函数查找     │ │
│  │ Register()   │  │ wrapFunction │  │ Get()        │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
│  ┌──────────────┐  ┌──────────────┐                   │
│  │ 批量注册     │  │ 恢复函数     │                   │
│  │ RegisterBatch│  │ RestoreFuncs │                   │
│  └──────────────┘  └──────────────┘                   │
└─────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────┐
│                    Storage (存储层)                      │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │ 保存元数据   │  │ 加载元数据   │  │ 查询函数     │ │
│  │ SaveFunction │  │ ListFunctions│  │ GetFunction  │ │
│  └──────────────┘  └──────────────┘  └──────────────┘ │
└─────────────────────────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────┐
│                    SQLite Database                      │
│  ┌──────────────┐  ┌──────────────┐                   │
│  │ functions表  │  │ tasks表      │                   │
│  │ (函数元数据) │  │ (任务定义)   │                   │
│  └──────────────┘  └──────────────┘                   │
└─────────────────────────────────────────────────────────┘
```

### 3.2 数据流

#### 3.2.1 函数注册流程

```
用户函数 → 验证函数签名 → 生成函数ID → 包装函数 → 保存元数据到数据库（仅ID、名称、描述） → 保存到内存
```

**注意**：不提取和存储参数类型信息，运行时从函数实例通过反射获取。

#### 3.2.2 函数恢复流程

```
数据库加载元数据 → 通过函数名称查找映射表 → 获取函数实例 → 包装函数 → 保存到内存
```

#### 3.2.3 任务执行流程

```
任务定义 → 通过函数ID查找函数 → 获取包装后的函数 → 异步执行 → 通过channel返回结果
```

## 4. 关键实现点

### 4.1 函数元数据提取

**简化设计**：不再提取和存储参数类型信息，只验证函数签名并保存基本信息。

```go
func extractFunctionMeta(fn interface{}, name, description string) (*FunctionMeta, error) {
    fnType := reflect.TypeOf(fn)
    
    // 只验证函数签名，不提取参数类型信息
    // 验证第一个参数必须是context.Context
    // 验证最后一个返回值必须是error
    
    return &FunctionMeta{
        Name:        name,
        Description: description,
        // 不再存储 ParamTypes 和 ReturnType
        // 运行时从函数实例通过反射获取类型信息
    }, nil
}
```

**关键点：**
- **只验证函数签名**：确保函数符合要求（第一个参数是context，最后返回值是error）
- **不提取类型信息**：参数类型和返回值类型不存储到数据库
- **运行时获取**：类型信息在 `wrapFunction` 时通过反射从函数实例获取
- **优势**：
  - 简化存储结构
  - 保证类型信息与函数定义同步
  - 支持自定义类型，无需特殊处理

### 4.2 函数包装机制

将任意函数包装为统一的 `TaskFunction` 签名：

```go
func wrapFunction(fn interface{}) (TaskFunction, error) {
    return func(ctx context.Context, params map[string]string) <-chan JobFunctionState {
        stateCh := make(chan JobFunctionState, 1)
        go func() {
            defer close(stateCh)
            
            // 使用反射调用函数
            results := fnValue.Call(args)
            
            // 处理返回值并发送到channel
            stateCh <- JobFunctionState{
                Status: "Success",
                Data:   result,
            }
        }()
        return stateCh
    }, nil
}
```

**关键点：**
- 使用反射动态调用函数
- **运行时获取类型信息**：从函数实例通过反射获取参数类型（`fnType.In(i)`）
- 异步执行（goroutine）
- 通过channel返回执行状态
- 支持参数类型自动转换（基于运行时获取的类型信息）

### 4.3 参数类型转换

支持字符串到基本类型的自动转换：

```go
func convertStringToType(value string, targetType reflect.Type) (reflect.Value, error) {
    switch targetType.Kind() {
    case reflect.String:
        return reflect.ValueOf(value), nil
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        intVal, err := strconv.ParseInt(value, 10, 64)
        return reflect.ValueOf(intVal).Convert(targetType), nil
    // ... 其他类型
    }
}
```

**支持的类型：**
- string
- int, int8, int16, int32, int64
- uint, uint8, uint16, uint32, uint64
- float32, float64
- bool

### 4.4 参数匹配策略

支持多种参数匹配方式，提高易用性：

1. **索引匹配**：`arg0`, `arg1`, `arg2`, ...
2. **位置匹配**：`param1`, `param2`, `param3`, ...
3. **类型名匹配**：使用参数类型名作为key
4. **默认值**：如果未找到，使用空字符串（可选参数）

### 4.5 并发安全

使用 `sync.RWMutex` 保护共享数据：

```go
type FunctionRegistry struct {
    mu        sync.RWMutex
    functions map[string]TaskFunction
    metaMap   map[string]*FunctionMeta
    storage   *Storage
}
```

**设计要点：**
- 读操作使用读锁（RLock），支持并发读
- 写操作使用写锁（Lock），互斥写
- 避免数据竞争和并发问题

### 4.6 数据库持久化

#### 4.6.1 表结构设计

**简化后的表结构**：只保存函数的基本信息，不存储参数类型。

```sql
CREATE TABLE IF NOT EXISTS functions (
    id TEXT PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,      -- 函数名称唯一约束
    description TEXT,
    create_time DATETIME NOT NULL
    -- 注意：不再存储 param_types 和 return_type
    -- 类型信息在运行时从函数实例通过反射获取
);

CREATE TABLE IF NOT EXISTS tasks (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    func_id TEXT NOT NULL,          -- 外键关联functions表
    params TEXT,                    -- JSON序列化的参数（map[string]string）
    create_time DATETIME NOT NULL,
    FOREIGN KEY(func_id) REFERENCES functions(id)
);
```

**设计说明：**
- **简化存储**：只保存函数ID、名称、描述和创建时间
- **类型信息获取**：参数类型和返回值类型在运行时通过反射从函数实例获取
- **优势**：
  - 减少存储空间
  - 保证类型信息与函数定义同步
  - 支持自定义类型，无需特殊处理

#### 4.6.2 序列化策略

- **任务参数序列化**：使用JSON序列化 `map[string]string`（任务参数）
- **时间格式**：使用 RFC3339 格式存储时间
- **数据一致性**：使用外键约束保证数据一致性
- **不再序列化**：函数参数类型信息不再序列化存储

## 5. 使用流程

### 5.1 函数定义

用户在package中定义函数：

```go
func MyTask(ctx context.Context, param1 string, param2 int) (string, error) {
    // 业务逻辑
    return result, nil
}
```

**函数签名要求：**
- 第一个参数必须是 `context.Context`
- 最后一个返回值必须是 `error`
- 支持基本类型参数

### 5.2 程序启动时注册

在 `main.go` 中初始化：

```go
// 1. 创建存储和注册中心
storage, _ := NewStorage("tasks.db")
registry := NewFunctionRegistry(storage)

// 2. 批量注册所有函数
functions := []FunctionDef{
    {Name: "MyTask", Description: "我的任务", Function: MyTask},
}
registry.RegisterBatch(ctx, functions)

// 3. 恢复已存在的函数（程序重启时）
funcMap := map[string]interface{}{
    "MyTask": MyTask,
}
registry.RestoreFunctions(ctx, funcMap)
```

### 5.3 创建任务

**方式1：通过函数引用创建（推荐）**

```go
task, err := NewTaskWithFunction(ctx, registry,
    "任务名称",
    "任务描述",
    MyTask,
    "MyTask",
    "我的任务",
)
task.Params["arg0"] = "value1"
task.Params["arg1"] = "100"
```

**方式2：通过函数ID创建**

```go
funcID := registry.GetIDByName("MyTask")
task := NewTask("任务名称", "任务描述", funcID)
task.Params["arg0"] = "value1"
```

### 5.4 执行任务

```go
// 获取函数
fn := registry.Get(task.FuncID)

// 执行任务（异步）
stateCh := fn(ctx, task.Params)
state := <-stateCh

if state.Status == "Success" {
    log.Printf("执行成功: %v", state.Data)
} else {
    log.Printf("执行失败: %v", state.Error)
}
```

## 6. 设计约束与限制

### 6.1 函数签名约束

- 第一个参数必须是 `context.Context`
- 最后一个返回值必须是 `error`
- 参数类型支持基本类型（string, int, float, bool等）
- **自定义类型支持**：由于类型信息在运行时获取，理论上支持任意类型，但参数转换需要相应支持
- **当前限制**：参数转换器目前只支持基本类型，自定义类型需要扩展转换器

### 6.2 函数实例要求

- 函数实例必须在程序启动时注册
- 程序重启后，函数实例需要重新注册（通过 `RestoreFunctions`）
- 函数名称必须唯一
- 函数名称作为恢复的桥梁，必须保持一致

### 6.3 数据持久化限制

- 只保存函数元数据（ID、名称、描述），不保存函数代码和类型信息
- 函数代码必须存在于二进制程序中
- 如果函数代码被删除，对应的任务将无法执行
- **类型信息不持久化**：参数类型和返回值类型不存储，运行时从函数实例获取
- **优势**：类型信息始终与函数定义同步，无需维护元数据

### 6.4 并发限制

- 函数注册和查找是线程安全的
- 函数执行是异步的，通过channel返回结果
- 不支持函数执行过程中的取消（可通过context实现）

## 7. 扩展性考虑

### 7.1 函数版本管理

未来可以支持函数版本管理：
- 在函数元数据中添加版本号
- 支持函数升级和回滚
- 任务可以指定使用的函数版本

### 7.2 函数代码序列化

未来可以支持函数代码的序列化：
- 使用Go plugin机制
- 支持动态加载函数代码
- 实现真正的函数持久化

### 7.3 参数类型扩展

由于类型信息在运行时获取，理论上支持任意类型，但需要扩展参数转换器：

- **slice类型**（[]string, []int等）：需要扩展转换器支持JSON反序列化
- **map类型**（map[string]string等）：需要扩展转换器支持JSON反序列化
- **自定义结构体类型**：需要扩展转换器支持JSON反序列化
- **类型别名**：由于运行时反射可以获取完整类型信息，支持类型别名

**实现建议**：
- 优先支持JSON序列化的类型（通过JSON反序列化实现）
- 提供类型转换器注册机制，支持自定义转换逻辑

### 7.4 函数自动发现

未来可以实现函数自动发现：
- 通过反射扫描包中的函数
- 自动识别符合签名的函数
- 减少手动注册的工作量

## 8. 最佳实践

### 8.1 函数命名规范

- 使用有意义的函数名称
- 保持函数名称唯一性
- 使用驼峰命名法

### 8.2 函数组织

- 将相关函数放在同一个package中
- 使用统一的函数映射表管理函数
- 在程序启动时集中注册所有函数

### 8.3 错误处理

- 函数应该返回有意义的错误信息
- 处理参数转换错误
- 处理函数执行错误

### 8.4 性能优化

- 批量注册函数，减少数据库操作
- 使用连接池管理数据库连接
- 合理使用并发锁，避免锁竞争

## 9. 测试策略

### 9.1 单元测试

- 测试函数注册功能
- 测试函数包装功能
- 测试参数类型转换
- 测试并发安全性

### 9.2 集成测试

- 测试函数保存和加载流程
- 测试程序重启后的恢复流程
- 测试任务创建和执行流程

### 9.3 性能测试

- 测试大量函数注册的性能
- 测试并发注册的性能
- 测试数据库操作的性能

## 10. 总结

任务函数保存与加载特性通过以下关键设计实现了持久化和自动恢复：

1. **简化元数据持久化**：只保存函数ID、名称、描述，不保存函数代码和类型信息
2. **运行时类型获取**：参数类型和返回值类型在运行时通过反射从函数实例获取，保证数据一致性
3. **名称映射机制**：通过函数名称连接元数据和函数实例
4. **统一包装**：所有函数包装为统一签名，便于管理
5. **异步执行**：通过channel实现异步执行和状态通知
6. **用户协作**：用户提供函数映射表，系统负责恢复

**核心设计优势：**
- **简化存储**：减少存储空间，简化数据库表结构
- **数据一致性**：类型信息始终与函数定义同步，无需维护元数据
- **支持自定义类型**：运行时反射可获取完整类型信息，支持任意类型
- **减少维护成本**：函数签名变更时自动反映，无需更新元数据

这种设计在保持灵活性的同时，实现了函数的持久化和自动加载，为任务调度引擎提供了可靠的基础设施。

