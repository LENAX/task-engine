# Task Engine 开发指南

本文档提供了 Task Engine 的完整开发指南，包括如何定义 Task、Workflow、Job Function、Handler、事务以及如何集成 HTTP API 路由。

## 目录

- [1. 定义 Job Function](#1-定义-job-function)
- [2. 定义 Task Handler](#2-定义-task-handler)
- [3. 定义 Task](#3-定义-task)
- [4. 定义 Workflow](#4-定义-workflow)
- [5. 定义 SAGA 事务](#5-定义-saga-事务)
- [6. 集成 HTTP API 路由](#6-集成-http-api-路由)
- [7. 完整示例](#7-完整示例)

---

## 1. 定义 Job Function

Job Function 是任务的核心业务逻辑函数，负责执行具体的业务操作。

### 1.1 函数签名

Job Function 支持两种函数签名：

#### 方式1：使用 TaskContext（推荐）

```go
func MyJobFunction(tc *task.TaskContext) (interface{}, error) {
    // 获取任务参数
    param1 := tc.GetParamString("param1")
    param2, _ := tc.GetParamInt("param2")
    
    // 获取依赖
    service, ok := tc.GetDependency("MyService")
    if ok {
        // 使用依赖服务
    }
    
    // 执行业务逻辑
    result := doSomething(param1, param2)
    
    // 返回结果（供下游任务使用）
    return map[string]interface{}{
        "result": result,
        "status": "success",
    }, nil
}
```

#### 方式2：使用标准 context.Context（兼容旧代码）

```go
func MyJobFunction(ctx context.Context) (interface{}, error) {
    // 从 context 中获取依赖
    service, ok := task.GetDependencyByKey(ctx, "MyService")
    if ok {
        // 使用依赖服务
    }
    
    // 执行业务逻辑
    result := doSomething()
    
    return result, nil
}
```

### 1.2 注册 Job Function

```go
import (
    "context"
    "github.com/LENAX/task-engine/pkg/core/task"
)

// 获取 Registry
registry := engine.GetRegistry()

// 注册函数
funcID, err := registry.Register(
    context.Background(),
    "MyJobFunction",           // 函数名称
    MyJobFunction,             // 函数实现
    "我的业务函数描述",         // 函数描述
)
if err != nil {
    log.Fatalf("注册函数失败: %v", err)
}
```

### 1.3 从上游任务获取结果

在 Job Function 中，可以通过 `_cached_` 前缀的参数获取上游任务的结果：

```go
func ProcessData(tc *task.TaskContext) (interface{}, error) {
    // 获取上游任务 "FetchData" 的结果
    upstreamResult := tc.GetParam("_cached_FetchData")
    if upstreamResult != nil {
        if resultMap, ok := upstreamResult.(map[string]interface{}); ok {
            data := resultMap["data"]
            // 处理数据
        }
    }
    
    return processedData, nil
}
```

### 1.4 模板任务的 Job Function

模板任务用于动态生成子任务，其 Job Function 需要：

1. 从上游任务获取数据列表
2. 为每个数据项创建一个子任务
3. 使用 `eng.AddSubTaskToInstance()` 添加子任务

```go
func GenerateSubTasks(tc *task.TaskContext) (interface{}, error) {
    // 1. 获取 Engine 依赖
    engineInterface, ok := tc.GetDependency("Engine")
    if !ok {
        return nil, fmt.Errorf("未找到Engine依赖")
    }
    eng := engineInterface.(*engine.Engine)
    registry := eng.GetRegistry()
    
    // 2. 从上游任务获取数据列表
    stockCodes := extractStockCodesFromUpstream(tc)
    
    // 3. 为每个数据项生成子任务
    parentTaskID := tc.TaskID
    workflowInstanceID := tc.WorkflowInstanceID
    
    for _, stockCode := range stockCodes {
        subTask, err := builder.NewTaskBuilder(
            fmt.Sprintf("处理_%s", stockCode),
            fmt.Sprintf("处理股票 %s", stockCode),
            registry,
        ).
            WithJobFunction("ProcessStock", map[string]interface{}{
                "stock_code": stockCode,
            }).
            Build()
        
        if err != nil {
            continue
        }
        
        // 4. 添加子任务到 Workflow 实例
        bgCtx := context.Background()
        eng.AddSubTaskToInstance(bgCtx, workflowInstanceID, subTask, parentTaskID)
    }
    
    return map[string]interface{}{
        "generated": len(stockCodes),
    }, nil
}
```

---

## 2. 定义 Task Handler

Task Handler 是任务状态变化时的回调函数，用于处理任务成功、失败等事件。

### 2.1 Handler 函数签名

```go
func MyHandler(tc *task.TaskContext) {
    // 获取任务信息
    taskName := tc.TaskName
    taskID := tc.TaskID
    status := tc.GetParamString("_status")
    
    // 处理逻辑
    log.Printf("任务 %s (ID: %s) 状态: %s", taskName, taskID, status)
    
    // 可以访问任务结果
    result := tc.GetParam("_result_data")
    
    // 可以访问错误信息
    if status == "Failed" {
        errMsg := tc.GetParamString("_error_message")
        log.Printf("任务失败: %s", errMsg)
    }
}
```

### 2.2 注册 Task Handler

```go
// 注册成功 Handler
registry.RegisterTaskHandler(
    context.Background(),
    "LogSuccess",              // Handler 名称
    LogSuccess,                // Handler 函数
    "记录任务成功日志",         // 描述
)

// 注册失败 Handler
registry.RegisterTaskHandler(
    context.Background(),
    "LogError",                // Handler 名称
    LogError,                  // Handler 函数
    "记录任务失败日志",         // 描述
)
```

### 2.3 可用的任务状态

- `task.TaskStatusSuccess` - 任务成功
- `task.TaskStatusFailed` - 任务失败
- `task.TaskStatusTimeout` - 任务超时
- `task.TaskStatusCancelled` - 任务取消

### 2.4 补偿函数（用于 SAGA 事务）

补偿函数也是一种 Task Handler，用于在事务失败时执行回滚操作：

```go
func CompensateOrder(tc *task.TaskContext) {
    // 获取原始任务参数
    orderID := tc.GetParamString("order_id")
    
    // 执行补偿逻辑（如回滚订单）
    log.Printf("补偿订单: %s", orderID)
    rollbackOrder(orderID)
}

// 注册补偿函数
registry.RegisterTaskHandler(
    context.Background(),
    "CompensateOrder",
    CompensateOrder,
    "订单补偿函数",
)
```

---

## 3. 定义 Task

Task 是 Workflow 中的基本执行单元，通过 TaskBuilder 构建。

### 3.1 基本 Task 定义

```go
import (
    "github.com/LENAX/task-engine/pkg/core/builder"
    "github.com/LENAX/task-engine/pkg/core/task"
)

// 创建 Task
task1, err := builder.NewTaskBuilder(
    "任务名称",                    // Task 名称（必须唯一）
    "任务描述",                    // Task 描述
    registry,                     // FunctionRegistry 实例
).
    WithJobFunction("MyJobFunction", map[string]interface{}{
        "param1": "value1",
        "param2": 100,
    }).
    WithTimeout(60).              // 超时时间（秒）
    WithRetryCount(3).             // 重试次数
    WithTaskHandler(task.TaskStatusSuccess, "LogSuccess").
    WithTaskHandler(task.TaskStatusFailed, "LogError").
    Build()
```

### 3.2 带依赖的 Task

```go
task2, err := builder.NewTaskBuilder(
    "下游任务",
    "依赖任务1的任务",
    registry,
).
    WithJobFunction("ProcessData", nil).
    WithDependency("任务名称").    // 依赖任务1
    Build()
```

### 3.3 多依赖 Task

```go
task3, err := builder.NewTaskBuilder(
    "聚合任务",
    "依赖多个任务",
    registry,
).
    WithJobFunction("AggregateData", nil).
    WithDependencies([]string{"任务1", "任务2"}).  // 依赖多个任务
    Build()
```

### 3.4 模板任务

模板任务用于动态生成子任务：

```go
templateTask, err := builder.NewTaskBuilder(
    "生成子任务",
    "为每个数据项生成子任务",
    registry,
).
    WithJobFunction("GenerateSubTasks", nil).
    WithDependency("获取数据列表").
    WithTemplate(true).            // 标记为模板任务
    Build()
```

### 3.5 带补偿函数的 Task（SAGA 事务）

```go
orderTask, err := builder.NewTaskBuilder(
    "创建订单",
    "创建新订单",
    registry,
).
    WithJobFunction("CreateOrder", map[string]interface{}{
        "order_id": "12345",
    }).
    WithCompensationFunction("CompensateOrder").  // 补偿函数
    Build()
```

### 3.6 结果映射（Result Mapping）

将上游任务的结果字段映射到下游任务的参数：

```go
task2, err := builder.NewTaskBuilder(
    "处理结果",
    "处理上游任务的结果",
    registry,
).
    WithJobFunction("ProcessResult", nil).
    WithDependency("上游任务").
    WithResultMapping(map[string]string{
        "data":      "input_data",    // 上游的 data 字段 -> 下游的 input_data 参数
        "count":     "total_count",   // 上游的 count 字段 -> 下游的 total_count 参数
    }).
    Build()
```

### 3.7 必需参数验证

```go
task1, err := builder.NewTaskBuilder(
    "验证任务",
    "验证必需参数",
    registry,
).
    WithJobFunction("ValidateData", nil).
    WithRequiredParams([]string{"param1", "param2"}).  // 必需参数列表
    Build()
```

---

## 4. 定义 Workflow

Workflow 是多个 Task 的组合，通过 WorkflowBuilder 构建。

### 4.1 基本 Workflow 定义

```go
import (
    "github.com/LENAX/task-engine/pkg/core/builder"
)

// 创建 Workflow
wf, err := builder.NewWorkflowBuilder(
    "我的工作流",                  // Workflow 名称
    "工作流描述",                  // Workflow 描述
).
    WithTask(task1).
    WithTask(task2).
    WithTask(task3).
    Build()
```

### 4.2 定时 Workflow（Cron）

```go
wf, err := builder.NewWorkflowBuilder(
    "定时任务",
    "每天凌晨执行",
).
    WithCronExpr("0 0 0 * * *").  // Cron 表达式（秒级精度）
    WithTask(task1).
    Build()
```

### 4.3 流处理模式 Workflow

```go
wf, err := builder.NewWorkflowBuilder(
    "流处理工作流",
    "实时处理数据流",
).
    WithStreamingMode().          // 设置为流处理模式
    WithTask(realtimeTask).
    Build()
```

### 4.4 批处理模式 Workflow（默认）

```go
wf, err := builder.NewWorkflowBuilder(
    "批处理工作流",
    "批量处理数据",
).
    WithBatchMode().              // 显式设置为批处理模式
    WithTask(task1).
    Build()
```

### 4.5 带自定义参数的 Workflow

```go
wf, err := builder.NewWorkflowBuilder(
    "参数化工作流",
    "使用自定义参数",
).
    WithParams(map[string]string{
        "env":     "production",
        "version": "v1.0",
    }).
    WithTask(task1).
    Build()
```

### 4.6 提交 Workflow 执行

```go
import (
    "context"
    "github.com/LENAX/task-engine/pkg/core/engine"
)

// 创建 Engine
eng, err := engine.NewEngine(10, 60, workflowRepo, instanceRepo, taskRepo)
if err != nil {
    log.Fatalf("创建 Engine 失败: %v", err)
}

// 启动 Engine
ctx := context.Background()
if err := eng.Start(ctx); err != nil {
    log.Fatalf("启动 Engine 失败: %v", err)
}
defer eng.Stop()

// 提交 Workflow
controller, err := eng.SubmitWorkflow(ctx, wf)
if err != nil {
    log.Fatalf("提交 Workflow 失败: %v", err)
}

// 等待完成
for {
    status := controller.Status()
    if status == "Success" || status == "Failed" {
        break
    }
    time.Sleep(500 * time.Millisecond)
}
```

---

## 5. 定义 SAGA 事务

SAGA 事务用于保证分布式事务的最终一致性，支持补偿机制。

### 5.1 启用 SAGA 事务

```go
import (
    "github.com/LENAX/task-engine/pkg/core/workflow"
)

// 创建 Workflow
wf := workflow.NewWorkflow("saga-workflow", "SAGA 事务工作流")
wf.SetTransactional(true)  // 启用 SAGA 事务
```

### 5.2 定义补偿函数

补偿函数是 Task Handler，用于在事务失败时执行回滚：

```go
// 补偿函数1：回滚订单创建
func CompensateCreateOrder(tc *task.TaskContext) {
    orderID := tc.GetParamString("order_id")
    log.Printf("补偿：回滚订单创建 %s", orderID)
    // 执行回滚逻辑
    deleteOrder(orderID)
}

// 补偿函数2：回滚库存扣减
func CompensateDeductStock(tc *task.TaskContext) {
    productID := tc.GetParamString("product_id")
    quantity := tc.GetParamInt("quantity")
    log.Printf("补偿：回滚库存扣减 %s x %d", productID, quantity)
    // 执行回滚逻辑
    restoreStock(productID, quantity)
}

// 注册补偿函数
registry.RegisterTaskHandler(ctx, "CompensateCreateOrder", CompensateCreateOrder, "订单创建补偿")
registry.RegisterTaskHandler(ctx, "CompensateDeductStock", CompensateDeductStock, "库存扣减补偿")
```

### 5.3 定义带补偿的 Task

```go
// Task 1: 创建订单
task1, err := builder.NewTaskBuilder(
    "创建订单",
    "创建新订单",
    registry,
).
    WithJobFunction("CreateOrder", map[string]interface{}{
        "order_id":   "12345",
        "user_id":    "user001",
        "product_id": "prod001",
        "quantity":   2,
    }).
    WithCompensationFunction("CompensateCreateOrder").  // 关联补偿函数
    Build()

// Task 2: 扣减库存
task2, err := builder.NewTaskBuilder(
    "扣减库存",
    "扣减商品库存",
    registry,
).
    WithJobFunction("DeductStock", map[string]interface{}{
        "product_id": "prod001",
        "quantity":   2,
    }).
    WithDependency("创建订单").
    WithCompensationFunction("CompensateDeductStock").  // 关联补偿函数
    Build()

// Task 3: 发送通知（无需补偿）
task3, err := builder.NewTaskBuilder(
    "发送通知",
    "发送订单确认通知",
    registry,
).
    WithJobFunction("SendNotification", map[string]interface{}{
        "order_id": "12345",
    }).
    WithDependency("扣减库存").
    // 注意：没有补偿函数，因为通知发送失败不需要回滚
    Build()
```

### 5.4 构建 SAGA Workflow

```go
// 创建 Workflow 并启用事务
wf := workflow.NewWorkflow("order-workflow", "订单处理工作流")
wf.SetTransactional(true)

// 添加 Task
wf.AddTask(task1)
wf.AddTask(task2)
wf.AddTask(task3)

// 构建依赖关系
wfBuilder := builder.NewWorkflowBuilder("order-workflow", "").
    WithTask(task1).
    WithTask(task2).
    WithTask(task3).
    Build()
```

### 5.5 SAGA 事务执行流程

1. **正常流程**：Task1 → Task2 → Task3，所有任务成功则事务提交
2. **失败流程**：
   - 如果 Task1 失败：直接终止，无需补偿
   - 如果 Task2 失败：执行 Task1 的补偿函数
   - 如果 Task3 失败：按反向顺序执行 Task2、Task1 的补偿函数

### 5.6 事务状态

- `Pending` - 待处理（初始状态）
- `Committed` - 已提交（所有步骤成功）
- `Compensating` - 补偿中（正在执行补偿）
- `Compensated` - 已补偿（补偿完成）
- `Failed` - 失败（补偿失败）

---

## 6. 集成 HTTP API 路由

Task Engine 提供了 HTTP API 服务器，支持通过 RESTful API 管理 Workflow。

### 6.1 创建 API 服务器

#### 基本使用

```go
import (
    "context"
    "github.com/LENAX/task-engine/pkg/api"
    "github.com/LENAX/task-engine/pkg/core/engine"
)

// 创建 Engine
eng, err := engine.NewEngine(10, 60, workflowRepo, instanceRepo, taskRepo)
if err != nil {
    log.Fatalf("创建 Engine 失败: %v", err)
}

// 启动 Engine
ctx := context.Background()
if err := eng.Start(ctx); err != nil {
    log.Fatalf("启动 Engine 失败: %v", err)
}
defer eng.Stop()

// 创建 API 服务器配置
config := api.DefaultServerConfig()
config.Host = "0.0.0.0"
config.Port = 8080

// 创建 API 服务器
apiServer := api.NewAPIServer(eng, config, "v1.0.0")

// 启动服务器（在 goroutine 中）
go func() {
    if err := apiServer.Start(); err != nil {
        log.Fatalf("启动 API 服务器失败: %v", err)
    }
}()

log.Printf("✅ API 服务器已启动: http://%s:%d", config.Host, config.Port)

// 优雅关闭
defer func() {
    shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    apiServer.Shutdown(shutdownCtx)
}()
```

#### 完整示例（带信号处理）

```go
package main

import (
    "context"
    "flag"
    "log"
    "os"
    "os/signal"
    "syscall"
    "time"
    
    "github.com/LENAX/task-engine/pkg/api"
    "github.com/LENAX/task-engine/pkg/core/engine"
)

func main() {
    // 命令行参数
    configPath := flag.String("config", "./configs/engine.yaml", "引擎配置文件路径")
    host := flag.String("host", "0.0.0.0", "监听地址")
    port := flag.Int("port", 8080, "监听端口")
    flag.Parse()
    
    // 1. 构建 Engine（使用配置文件）
    eng, err := engine.NewEngineBuilder(*configPath).
        RestoreFunctionsOnStart().  // 启动时恢复函数
        Build()
    if err != nil {
        log.Fatalf("创建 Engine 失败: %v", err)
    }
    
    // 2. 启动 Engine
    ctx := context.Background()
    if err := eng.Start(ctx); err != nil {
        log.Fatalf("启动 Engine 失败: %v", err)
    }
    
    // 3. 创建 API 服务器
    config := api.ServerConfig{
        Host:         *host,
        Port:         *port,
        ReadTimeout:  30 * time.Second,
        WriteTimeout: 30 * time.Second,
    }
    
    apiServer := api.NewAPIServer(eng, config, "v1.0.0")
    
    // 4. 在 goroutine 中启动 API 服务器
    go func() {
        if err := apiServer.Start(); err != nil {
            log.Printf("API 服务器错误: %v", err)
        }
    }()
    
    log.Printf("✅ Task Engine Server started on %s:%d", *host, *port)
    
    // 5. 等待中断信号（优雅关闭）
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    
    log.Println("正在关闭服务...")
    
    // 6. 优雅关闭
    shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := apiServer.Shutdown(shutdownCtx); err != nil {
        log.Printf("关闭 API 服务器失败: %v", err)
    }
    
    eng.Stop()
    log.Println("✅ 服务已停止")
}
```

### 6.2 使用自定义路由

#### 方式1：在现有路由基础上添加

```go
import (
    "github.com/gin-gonic/gin"
    "github.com/LENAX/task-engine/pkg/api"
)

// 获取默认路由
router := api.SetupRouter(eng, "v1.0.0")

// 添加自定义路由
customGroup := router.Group("/api/v1/custom")
{
    customGroup.GET("/status", func(c *gin.Context) {
        c.JSON(200, gin.H{"status": "ok"})
    })
    
    customGroup.POST("/custom-action", func(c *gin.Context) {
        // 自定义处理逻辑
        c.JSON(200, gin.H{"result": "success"})
    })
}
```

#### 方式2：创建自定义路由函数

如果需要完全自定义路由，可以创建自己的路由设置函数：

```go
package main

import (
    "github.com/gin-gonic/gin"
    "github.com/LENAX/task-engine/pkg/api"
    "github.com/LENAX/task-engine/pkg/api/handler"
    "github.com/LENAX/task-engine/pkg/api/middleware"
    "github.com/LENAX/task-engine/pkg/core/engine"
)

// SetupCustomRouter 创建自定义路由
func SetupCustomRouter(eng *engine.Engine, version string) *gin.Engine {
    gin.SetMode(gin.ReleaseMode)
    router := gin.New()
    
    // 全局中间件
    router.Use(middleware.Recovery())
    router.Use(middleware.Logger())
    router.Use(middleware.CORS())
    
    // 创建标准 handlers
    workflowHandler := handler.NewWorkflowHandler(eng)
    instanceHandler := handler.NewInstanceHandler(eng)
    healthHandler := handler.NewHealthHandler(version)
    
    // 健康检查
    router.GET("/health", healthHandler.Health)
    router.GET("/ready", healthHandler.Ready)
    
    // API v1 路由组
    v1 := router.Group("/api/v1")
    {
        // 标准 Workflow 路由
        workflows := v1.Group("/workflows")
        {
            workflows.GET("", workflowHandler.List)
            workflows.POST("", workflowHandler.Upload)
            workflows.GET("/:id", workflowHandler.Get)
            workflows.DELETE("/:id", workflowHandler.Delete)
            workflows.POST("/:id/execute", workflowHandler.Execute)
            workflows.GET("/:id/history", workflowHandler.History)
        }
        
        // 标准 Instance 路由
        instances := v1.Group("/instances")
        {
            instances.GET("", instanceHandler.List)
            instances.GET("/:id", instanceHandler.Get)
            instances.GET("/:id/tasks", instanceHandler.GetTasks)
            instances.POST("/:id/pause", instanceHandler.Pause)
            instances.POST("/:id/resume", instanceHandler.Resume)
            instances.POST("/:id/cancel", instanceHandler.Cancel)
        }
        
        // 自定义路由
        custom := v1.Group("/custom")
        {
            custom.GET("/status", func(c *gin.Context) {
                c.JSON(200, gin.H{"status": "ok"})
            })
            
            custom.POST("/action", func(c *gin.Context) {
                // 自定义处理逻辑
                c.JSON(200, gin.H{"result": "success"})
            })
        }
    }
    
    return router
}

// 使用自定义路由
func main() {
    eng, _ := engine.NewEngine(...)
    router := SetupCustomRouter(eng, "v1.0.0")
    
    // 启动服务器
    httpServer := &http.Server{
        Addr:    ":8080",
        Handler: router,
    }
    httpServer.ListenAndServe()
}
```

#### 方式3：修改 api.SetupRouter 函数

如果需要修改框架提供的路由，可以：

1. Fork `pkg/api/router.go` 文件
2. 修改 `SetupRouter` 函数添加自定义路由
3. 或者创建新的路由设置函数

### 6.3 可用的 API 端点

#### Workflow 管理

| 方法 | 路径 | 功能 |
|------|------|------|
| POST | `/api/v1/workflows` | 上传/保存 Workflow 定义（YAML） |
| GET | `/api/v1/workflows` | 列出所有 Workflow |
| GET | `/api/v1/workflows/:id` | 查看 Workflow 详情 |
| DELETE | `/api/v1/workflows/:id` | 删除 Workflow |
| POST | `/api/v1/workflows/:id/execute` | 执行 Workflow |
| GET | `/api/v1/workflows/:id/history` | 查询 Workflow 执行历史 |

#### Instance 管理

| 方法 | 路径 | 功能 |
|------|------|------|
| GET | `/api/v1/instances` | 列出所有 Instance |
| GET | `/api/v1/instances/:id` | 查询执行进度/状态 |
| GET | `/api/v1/instances/:id/tasks` | 查询任务详情 |
| POST | `/api/v1/instances/:id/pause` | 暂停执行 |
| POST | `/api/v1/instances/:id/resume` | 恢复执行 |
| POST | `/api/v1/instances/:id/cancel` | 取消执行 |

#### 健康检查

| 方法 | 路径 | 功能 |
|------|------|------|
| GET | `/health` | 健康检查 |
| GET | `/ready` | 就绪检查 |

### 6.4 API 请求示例

#### 上传 Workflow

```bash
curl -X POST http://localhost:8080/api/v1/workflows \
  -H "Content-Type: application/yaml" \
  --data-binary @workflow.yaml
```

#### 执行 Workflow

```bash
curl -X POST http://localhost:8080/api/v1/workflows/{workflow_id}/execute \
  -H "Content-Type: application/json" \
  -d '{"params": {"key": "value"}}'
```

#### 查询 Instance 状态

```bash
curl http://localhost:8080/api/v1/instances/{instance_id}
```

### 6.5 自定义 Handler

如果需要添加自定义 Handler，可以创建新的 Handler 文件：

```go
package handler

import (
    "github.com/gin-gonic/gin"
    "github.com/LENAX/task-engine/pkg/core/engine"
)

type CustomHandler struct {
    engine *engine.Engine
}

func NewCustomHandler(eng *engine.Engine) *CustomHandler {
    return &CustomHandler{engine: eng}
}

func (h *CustomHandler) CustomAction(c *gin.Context) {
    // 自定义处理逻辑
    c.JSON(200, gin.H{"result": "success"})
}
```

然后在 `SetupRouter` 中注册：

```go
func SetupRouter(eng *engine.Engine, version string) *gin.Engine {
    router := gin.New()
    
    // ... 现有路由 ...
    
    // 添加自定义路由
    customHandler := handler.NewCustomHandler(eng)
    v1 := router.Group("/api/v1")
    {
        v1.GET("/custom", customHandler.CustomAction)
    }
    
    return router
}
```

---

## 7. 完整示例

以下是一个完整的示例，展示了如何定义和使用 Task Engine 的各个组件：

```go
package main

import (
    "context"
    "log"
    "time"
    
    "github.com/LENAX/task-engine/internal/storage/sqlite"
    "github.com/LENAX/task-engine/pkg/core/builder"
    "github.com/LENAX/task-engine/pkg/core/engine"
    "github.com/LENAX/task-engine/pkg/core/task"
)

// 1. 定义 Job Functions
func FetchData(tc *task.TaskContext) (interface{}, error) {
    log.Println("获取数据...")
    time.Sleep(100 * time.Millisecond)
    return map[string]interface{}{
        "data":  []string{"item1", "item2", "item3"},
        "count": 3,
    }, nil
}

func ProcessItem(tc *task.TaskContext) (interface{}, error) {
    item := tc.GetParamString("item")
    log.Printf("处理项目: %s", item)
    time.Sleep(50 * time.Millisecond)
    return map[string]interface{}{
        "item":   item,
        "status": "processed",
    }, nil
}

func AggregateResults(tc *task.TaskContext) (interface{}, error) {
    log.Println("聚合结果...")
    return map[string]interface{}{
        "total": 3,
        "status": "completed",
    }, nil
}

// 2. 定义 Handlers
func LogSuccess(tc *task.TaskContext) {
    log.Printf("✅ 任务成功: %s", tc.TaskName)
}

func LogError(tc *task.TaskContext) {
    errMsg := tc.GetParamString("_error_message")
    log.Printf("❌ 任务失败: %s, 错误: %s", tc.TaskName, errMsg)
}

// 3. 主函数
func main() {
    // 创建 Repository 和 Engine
    repos, _ := sqlite.NewRepositories("./engine.db")
    eng, _ := engine.NewEngine(10, 60, repos.Workflow, repos.WorkflowInstance, repos.Task)
    
    ctx := context.Background()
    eng.Start(ctx)
    defer eng.Stop()
    
    // 注册函数
    registry := eng.GetRegistry()
    registry.Register(ctx, "FetchData", FetchData, "获取数据")
    registry.Register(ctx, "ProcessItem", ProcessItem, "处理项目")
    registry.Register(ctx, "AggregateResults", AggregateResults, "聚合结果")
    registry.RegisterTaskHandler(ctx, "LogSuccess", LogSuccess, "成功日志")
    registry.RegisterTaskHandler(ctx, "LogError", LogError, "错误日志")
    
    // 构建 Task
    task1, _ := builder.NewTaskBuilder("获取数据", "获取数据列表", registry).
        WithJobFunction("FetchData", nil).
        WithTaskHandler(task.TaskStatusSuccess, "LogSuccess").
        WithTaskHandler(task.TaskStatusFailed, "LogError").
        Build()
    
    task2, _ := builder.NewTaskBuilder("处理数据", "处理每个数据项", registry).
        WithJobFunction("ProcessItem", nil).
        WithDependency("获取数据").
        WithTemplate(true).  // 模板任务
        Build()
    
    task3, _ := builder.NewTaskBuilder("聚合结果", "聚合所有结果", registry).
        WithJobFunction("AggregateResults", nil).
        WithDependency("处理数据").
        WithTaskHandler(task.TaskStatusSuccess, "LogSuccess").
        Build()
    
    // 构建 Workflow
    wf, _ := builder.NewWorkflowBuilder("数据处理流程", "完整的数据处理流程").
        WithTask(task1).
        WithTask(task2).
        WithTask(task3).
        Build()
    
    // 提交执行
    controller, _ := eng.SubmitWorkflow(ctx, wf)
    log.Printf("Workflow 已提交，InstanceID: %s", controller.InstanceID())
    
    // 等待完成
    for {
        status := controller.Status()
        if status == "Success" || status == "Failed" {
            log.Printf("Workflow 完成，状态: %s", status)
            break
        }
        time.Sleep(500 * time.Millisecond)
    }
}
```

---

## 总结

本文档涵盖了 Task Engine 的核心开发概念：

1. **Job Function**：定义业务逻辑
2. **Task Handler**：处理任务状态变化
3. **Task**：使用 TaskBuilder 构建任务
4. **Workflow**：使用 WorkflowBuilder 组合任务
5. **SAGA 事务**：实现分布式事务的最终一致性
6. **HTTP API**：通过 RESTful API 管理 Workflow

更多详细信息，请参考：
- [示例代码](../../examples/example_workflow/main.go)
- [E2E 测试](../../test/e2e/e2e_test.go)
- [设计文档](../dev/动态添加子任务的设计.md)
